{
      "cells": [
                 {
                          "source": "# Rel Onboarding: Rel Syntax\n\nWelcome to the Rel workshop!\n\nIn this class we'll be learning the basics of the Rel language.\nThe focus here is on the Rel syntax and not so much on the business impact.\n\nOutline:\n- Data types\n- Tuples\n- Relations\n- Persisting Relations\n- Relation Abstraction\n- Relation Application\n\nTo get started:\n- [Rel Tutorials](https://docs.relational.ai/getting-started/rel/overview/): Introductory tutorials to Rel\n- [Rel Primer](https://docs.relational.ai/rel/primer/overview/): Comprehensive Guide to all key Rel modelling and syntax concepts.\n- [Docs Walkthrough](https://docs.relational.ai/getting-started/intro/walkthrough/): Guide to help you work through our documentation.\n\n\n## Data Types\n\nWe have all the basic data types:\n- strings: `\"abc\"`\n- numbers: `1`, `-0.2`, ....\n- dates: `2022-02-01`, ...\n- ...\n\nYou can see all of the data types (including the ones we are not covering in this workshop) in our [Data type reference guide](https://docs.relational.ai/rel/ref/data-types/).",
                              "id": "1",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = 1",
                        "id": "2",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "The statement `def output = ...` defines what result are shown.",
                              "id": "3",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "// string values\ndef output = \"Alice\"",
                        "id": "4",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "The math operators `+-*/` work as you'd expect.",
                              "id": "5",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = 15 + 17",
                        "id": "6",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "## Tuples\n\nRel has tuples.\n**Tuples are ordered collections of data values.**\nA tuple may hold none, one, or many data values. \n\nHint: You may think of tuples as rows in a table.",
                              "id": "7",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "// Here's a tuple!\ndef output = (\"Dylan\", \"Bob\")",
                        "id": "8",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "",
                              "id": "9",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "// you can have different data types in the same tuple\ndef output = (\"Alex\", 5)",
                        "id": "10",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "",
                              "id": "11",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "// you can have multiple values in the same tutple, since it's ordered\ndef output = (1, 1, 1, 1, 1, 1, 1, 1, 1)",
                        "id": "12",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "## Relations (The Heart of Rel)\n\nTechnically, a relation is a set of tuples.\n\nReminder: A set is an unordered collection of unique entries.\n\nMultiple entries in a relation are delimited with **semicolons**. You can also wrap the whole set in braces (`{}`).\n\nA relation can be defined with `def R = ...` where `R` is the name of the relation.\n\nAs you noticed, we already used relations quite heavily with `def output = `.\nThe relation `output` has a special purpose as it informs the RKGMS which data to return.",
                              "id": "13",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def age = {(\"Adam\", 24); (\"Adam\", 24); (\"Eve\", 30)}\ndef output = age",
                        "id": "14",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "In Rel, we don't need to state the data type in a relation.\nRelations can have multiple data types in the same position.",
                              "id": "15",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def age = {(\"Adam\", 25); (\"Eve\",  Year[30]);}\ndef output = age",
                        "id": "16",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "Relations can even consists of tuples that have length of tuples (aka arities).",
                              "id": "17",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def today = {\n    (2022-02-03);\n    (2022, 02, 03)\n}\n\ndef output = today",
                        "id": "18",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "Multiple definition statements get unioned *not overwritten*.",
                              "id": "19",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "// sets are unique. Adding the value twice doesn't add it twice.\ndef name = {\"Alice\"; \"Bob\"}\n\n// If you define the same value twice, the definitions are added together.\ndef name = {\"Alice\"; \"Carol\"}\n\n// notice how \"Alice\" and \"Bob\" each show in the output ONCE.\ndef output = name",
                        "id": "20",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "### Checking a tuple is in a relation.",
                              "id": "21",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def student_class = {\n  (\"Alice\", \"Bio\");\n  (\"Bob\", \"Bio\");\n  (\"Carol\", \"Math\")\n}\n\n// Does Alice have a Bio class?\ndef output = student_class(\"Alice\", \"Bio\")",
                        "id": "22",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "",
                              "id": "23",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def student_class = {\n  (\"Alice\", \"Bio\");\n  (\"Bob\", \"Bio\");\n  (\"Carol\", \"Math\")\n}\n\n//If the answer is FALSE, then there's no output.\ndef output = student_class(\"Bob\", \"Math\")",
                        "id": "24",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "### Any value (existential quantification) \n\n\nWe can use an underscore `_` for specifying \"any value\".\nIn DB-speak that is known as existential quantification.\n\nThis is useful when asking, for instance, did anyone took Bio?",
                              "id": "25",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def student_class = {\n  (\"Alice\", \"Bio\");\n  (\"Bob\", \"Bio\");\n  (\"Carol\", \"Math\")\n}\n\ndef output = student_class(_, \"Bio\")",
                        "id": "26",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "The underscore can be also used for any element in the relation.\n\nFor instance, let's assume we have a arity 3 (tuples with 3 elements) relation `grades` that connects students with it a class and their grade in that class.",
                              "id": "27",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "// underscore is useful if you have a larger relation.\ndef score = {\n  (\"Alice\", \"Bio\", 70);\n  (\"Alice\", \"Math\", 80)\n}\n\n// Does Alice have a 70 score in any class?\ndef output = score(\"Alice\", _, 70)",
                        "id": "28",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "## Installing Relations\n\nHmm, why do we need to define `student_class` every time?\n\nAnswer: So far we only used *query* cell, which can be used to define queries and complex logic  to extract knowledge from the database but these definitions are forgotten afterwards.\n\nTo make relation definitions persistent, we need to _install_ them!\nWe call this installing a model.\nIn the notebook we have dedicated _install cells_ to install models.\n\nSide note: There are exists also EDB relations, whose purpose is to store the actual data.\nHowever, introducing them is beyond the scope of this workshop.\n\nIDB relations -- what we are using here -- are known as _views_ that is logic build on top of EDB data.\nOut of convenience, we use logic to define our toy data and \"store\" them in IDB relations.\n\nSo, let's install some logic.",
                              "id": "29",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                      "name": "takes_class",
                    "source": "def takes_class = {\n  (\"Alice\", \"Bio\");\n  (\"Bob\", \"Bio\");\n  (\"Carol\", \"Math\")\n}",
                        "id": "30",
                      "type": "install",
                    "inputs": []
                 },
                 {
                          "source": "Now `takes_class` is installed, and we can refer to it in any other cell (even in a cell above).",
                              "id": "31",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = takes_class(\"Alice\", \"Bio\")",
                        "id": "32",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "## Relational Abstraction\n\nOnce we have relations, we want to be able to do things with it!",
                              "id": "33",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def bio_classroom = x: takes_class(x, \"Bio\")\n\ndef output = bio_classroom",
                        "id": "34",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "This is equivalent to",
                              "id": "35",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def bio_classroom(x) = takes_class(x, \"Bio\")\n\ndef output = bio_classroom",
                        "id": "36",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "### Formula\n\nWe can also rewrite the above by moving the abstraction to the left-hand side. Almost like it's a programming function!\n\nIf you do this, the right-hand side **must** evaluate to `true` or `false`.\nIt can't evaluate to a relation, that's not allowed.",
                              "id": "37",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def classrooms(class, person) = school_class(person, class)\n\ndef output = classrooms",
                        "id": "38",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "",
                              "id": "39",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "// TODO maybe we shouldn't discuss this?\n// You can't do this, though:\ndef classrooms(\"bio\") = \"alice\"\n\ndef output = add(2, 3)",
                        "id": "40",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "## Unbound Relations\n## Application\n\nThis is where we introduce `[]`",
                              "id": "41",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "/*\n\ndef bio_classroom = person: classes(person, \"bio\")\ndef output[:a] = classrooms\n\ndef mutuals = x, y: exists(z: classes(x, z) and classes(y, z))\n\ndef output[:b] = mutuals\n\ndef scores = {\n  (\"alice\", \"bio\", 10);\n  (\"bob\", \"bio\", 9);\n  (\"carol\", \"bio\", 12);\n  (\"alice\", \"econ\", 11);\n}\n\ndef incomplete(person, class) = classes(person, class) and not scores(person, class, _)\n// Do you have a score in a class you didn't take?\n//def output[:c] = class: top[2, (scores[user, class], user from user)]\n//def output[:c] = user: top[2, (scores[user, class], class from class)]\n//def output[:c] = user: top[2, (s, c: scores(user, c, s))]\ndef output[:d] = c, top[2, scores[u, c]] from u, c\n\n//def output[:c] = top[3, (scores[user, class], user, class from user, class)]\n\n/*\nThis \ndef classes = {\n\t(1, :person, \"alice\");\n    (1, :class, \"bio\");\n    (1, :score, 11);\n}\n\ndef classes[1] = {\n\t(:person, \"alice\");\n    (:class, \"bio\");\n    (:score, 11);\n}\n\ndef incomplete(person, class) = classes(class, :person, person) and not classes(classes, :score, _)\n */",
                        "id": "42",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "## The Nitty-Gritty\n\n### Tuples\n\nThe length of a tuple is called _arity_.\n\nThe arity of `(2, 2, 2)` is 3.",
                              "id": "43",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = arity[(2,2,2)]",
                        "id": "44",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "Tuples can *not* be collections of tuples.\nTuples of tuples will be flattened into a tuple of values.",
                              "id": "45",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = ((1,2), (3, 4))",
                        "id": "46",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "A tuple of one value behaves like ... a value!",
                              "id": "47",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = (1, ) + 2",
                        "id": "48",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "The empty tuple is special and represents `true`.",
                              "id": "49",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = ()",
                        "id": "50",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "### Relation\n\nA tuple is a relation of cardinality 1 (relation has only one tuple in the collection).",
                              "id": "51",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def R = (\"a\", \"b\")\ndef output = R",
                        "id": "52",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "A data value is a relation of cardinality 1 and arity 1.",
                              "id": "53",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def R = {(1,)}\ndef output = R + 2",
                        "id": "54",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "As we can see: **everything is a relation**.\nRelations within tuples get expanded into a relation of tuples.\n\n\n#### Relations within Relations get expanded\n\nRelations within tuples get expanded into a relation of tuples.",
                              "id": "55",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = (1, {2; 3})",
                        "id": "56",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "We can verify that when explicitly writing it as a set of tuples.",
                              "id": "57",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def output = {(1, 2) ; (1, 3)}",
                        "id": "58",
                      "type": "query",
                    "inputs": []
                 },
                 {
                          "source": "You also cannot put a relation in another relation.\nIf you try, Rel will \"expand\" the relation in a set of tuples.",
                              "id": "59",
                    "isCodeFolded": true,
                            "type": "markdown",
                          "inputs": []
                 },
                 {
                    "source": "def R = {1; 2; 3}\ndef S = {\"a\"; \"b\"; \"c\"}\ndef T = {R; S}\n\ndef output = T",
                        "id": "60",
                      "type": "query",
                    "inputs": []
                 }
               ],
   "metadata": {
                  "notebookFormatVersion": "0.0.1"
               }
}